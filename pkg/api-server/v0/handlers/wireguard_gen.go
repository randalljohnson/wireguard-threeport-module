// generated by 'threeport-sdk gen' - do not edit

package handlers

import (
	"errors"
	"fmt"
	echo "github.com/labstack/echo/v4"
	notif "github.com/randalljohnson/wireguard-threeport-module/internal/wireguard/notif"
	api_v0 "github.com/randalljohnson/wireguard-threeport-module/pkg/api/v0"
	tpapiserver_lib "github.com/threeport/threeport/pkg/api-server/lib/v0"
	tpapi_v0 "github.com/threeport/threeport/pkg/api/v0"
	notifications "github.com/threeport/threeport/pkg/notifications/v0"
	gorm "gorm.io/gorm"
	"net/http"
	"time"
)

///////////////////////////////////////////////////////////////////////////////
// WireguardDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetWireguardDefinitionVersions gets the supported versions for the wireguard definition API.
// @Description Get the supported API versions for wireguard definitions.
// @ID wireguardDefinition-get-versions
// @Produce json
// @Success 200 {object} tpapiserver_lib.ApiObjectVersions "OK"
// @Router /randalljohnson-us/wireguard-definitions/versions [GET]
func (h Handler) GetWireguardDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, tpapiserver_lib.ObjectVersions[string(api_v0.ObjectTypeWireguardDefinition)])
}

// @Summary adds a new wireguard definition.
// @Description Add a new wireguard definition to the Threeport database.
// @ID add-v0-wireguardDefinition
// @Accept json
// @Produce json
// @Param wireguardDefinition body api_v0.WireguardDefinition true "WireguardDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-definitions [POST]
func (h Handler) AddWireguardDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardDefinition
	var wireguardDefinition api_v0.WireguardDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := tpapiserver_lib.PayloadCheck(c, true, false, objectType, wireguardDefinition); err != nil {
		return tpapiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&wireguardDefinition); err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := tpapiserver_lib.ValidateBoundData(c, wireguardDefinition, objectType); err != nil {
		return tpapiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingWireguardDefinition api_v0.WireguardDefinition
	nameUsed := true
	result := h.Handler.DB.Where("name = ?", wireguardDefinition.Name).First(&existingWireguardDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return tpapiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.Handler.DB.Create(&wireguardDefinition); result.Error != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*wireguardDefinition.Reconciled {
		notifPayload, err := wireguardDefinition.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.Handler.JS.Publish(notif.WireguardDefinitionCreateSubject, *notifPayload)
	}

	response, err := tpapiserver_lib.CreateResponse(nil, wireguardDefinition, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all wireguard definitions.
// @Description Get all wireguard definitions from the Threeport database.
// @ID get-v0-wireguardDefinitions
// @Accept json
// @Produce json
// @Param name query string false "wireguard definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-definitions [GET]
func (h Handler) GetWireguardDefinitions(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardDefinition
	params, err := c.(*tpapiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return tpapiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.WireguardDefinition
	if err := c.Bind(&filter); err != nil {
		return tpapiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.Handler.DB.Model(&api_v0.WireguardDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return tpapiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.WireguardDefinition{}
	if result := h.Handler.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return tpapiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := tpapiserver_lib.CreateResponse(tpapiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a wireguard definition.
// @Description Get a particular wireguard definition from the database.
// @ID get-v0-wireguardDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-definitions/{id} [GET]
func (h Handler) GetWireguardDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardDefinition
	wireguardDefinitionID := c.Param("id")
	var wireguardDefinition api_v0.WireguardDefinition
	if result := h.Handler.DB.First(&wireguardDefinition, wireguardDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return tpapiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := tpapiserver_lib.CreateResponse(nil, wireguardDefinition, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing wireguard definition.
// @Description Update a wireguard definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating wireguard definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-wireguardDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param wireguardDefinition body api_v0.WireguardDefinition true "WireguardDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-definitions/{id} [PATCH]
func (h Handler) UpdateWireguardDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardDefinition
	wireguardDefinitionID := c.Param("id")
	var existingWireguardDefinition api_v0.WireguardDefinition
	if result := h.Handler.DB.First(&existingWireguardDefinition, wireguardDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return tpapiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := tpapiserver_lib.PayloadCheck(c, true, true, objectType, existingWireguardDefinition); err != nil {
		return tpapiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedWireguardDefinition api_v0.WireguardDefinition
	if err := c.Bind(&updatedWireguardDefinition); err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.Handler.DB.Model(&existingWireguardDefinition).Updates(updatedWireguardDefinition); result.Error != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingWireguardDefinition.Reconciled {
		notifPayload, err := existingWireguardDefinition.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.Handler.JS.Publish(notif.WireguardDefinitionUpdateSubject, *notifPayload)
	}

	response, err := tpapiserver_lib.CreateResponse(nil, existingWireguardDefinition, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing wireguard definition by replacing the entire object.
// @Description Replace a wireguard definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating wireguard definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-wireguardDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param wireguardDefinition body api_v0.WireguardDefinition true "WireguardDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-definitions/{id} [PUT]
func (h Handler) ReplaceWireguardDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardDefinition
	wireguardDefinitionID := c.Param("id")
	var existingWireguardDefinition api_v0.WireguardDefinition
	if result := h.Handler.DB.First(&existingWireguardDefinition, wireguardDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return tpapiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := tpapiserver_lib.PayloadCheck(c, true, true, objectType, existingWireguardDefinition); err != nil {
		return tpapiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedWireguardDefinition api_v0.WireguardDefinition
	if err := c.Bind(&updatedWireguardDefinition); err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := tpapiserver_lib.ValidateBoundData(c, updatedWireguardDefinition, objectType); err != nil {
		return tpapiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedWireguardDefinition.ID = existingWireguardDefinition.ID
	if result := h.Handler.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedWireguardDefinition); result.Error != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.Handler.DB.First(&existingWireguardDefinition, wireguardDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return tpapiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := tpapiserver_lib.CreateResponse(nil, existingWireguardDefinition, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a wireguard definition.
// @Description Delete a wireguard definition by ID from the database.
// @ID delete-v0-wireguardDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-definitions/{id} [DELETE]
func (h Handler) DeleteWireguardDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardDefinition
	wireguardDefinitionID := c.Param("id")
	var wireguardDefinition api_v0.WireguardDefinition
	if result := h.Handler.DB.Preload("WireguardInstances").First(&wireguardDefinition, wireguardDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return tpapiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check to make sure no dependent instances exist for this definition
	if len(wireguardDefinition.WireguardInstances) != 0 {
		err := errors.New("wireguard definition has related wireguard instances - cannot be deleted")
		return tpapiserver_lib.ResponseStatus409(c, nil, err, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if wireguardDefinition.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledWireguardDefinition := api_v0.WireguardDefinition{
			Reconciliation: tpapi_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.Handler.DB.Model(&wireguardDefinition).Updates(scheduledWireguardDefinition); result.Error != nil {
			return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := wireguardDefinition.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.Handler.JS.Publish(notif.WireguardDefinitionDeleteSubject, *notifPayload)
	} else {
		if wireguardDefinition.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return tpapiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*wireguardDefinition.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.Handler.DB.Delete(&wireguardDefinition); result.Error != nil {
				return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := tpapiserver_lib.CreateResponse(nil, wireguardDefinition, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// WireguardInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetWireguardInstanceVersions gets the supported versions for the wireguard instance API.
// @Description Get the supported API versions for wireguard instances.
// @ID wireguardInstance-get-versions
// @Produce json
// @Success 200 {object} tpapiserver_lib.ApiObjectVersions "OK"
// @Router /randalljohnson-us/wireguard-instances/versions [GET]
func (h Handler) GetWireguardInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, tpapiserver_lib.ObjectVersions[string(api_v0.ObjectTypeWireguardInstance)])
}

// @Summary adds a new wireguard instance.
// @Description Add a new wireguard instance to the Threeport database.
// @ID add-v0-wireguardInstance
// @Accept json
// @Produce json
// @Param wireguardInstance body api_v0.WireguardInstance true "WireguardInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-instances [POST]
func (h Handler) AddWireguardInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardInstance
	var wireguardInstance api_v0.WireguardInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := tpapiserver_lib.PayloadCheck(c, true, false, objectType, wireguardInstance); err != nil {
		return tpapiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&wireguardInstance); err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := tpapiserver_lib.ValidateBoundData(c, wireguardInstance, objectType); err != nil {
		return tpapiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingWireguardInstance api_v0.WireguardInstance
	nameUsed := true
	result := h.Handler.DB.Where("name = ?", wireguardInstance.Name).First(&existingWireguardInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return tpapiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.Handler.DB.Create(&wireguardInstance); result.Error != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*wireguardInstance.Reconciled {
		notifPayload, err := wireguardInstance.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.Handler.JS.Publish(notif.WireguardInstanceCreateSubject, *notifPayload)
	}

	response, err := tpapiserver_lib.CreateResponse(nil, wireguardInstance, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all wireguard instances.
// @Description Get all wireguard instances from the Threeport database.
// @ID get-v0-wireguardInstances
// @Accept json
// @Produce json
// @Param name query string false "wireguard instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-instances [GET]
func (h Handler) GetWireguardInstances(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardInstance
	params, err := c.(*tpapiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return tpapiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.WireguardInstance
	if err := c.Bind(&filter); err != nil {
		return tpapiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.Handler.DB.Model(&api_v0.WireguardInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return tpapiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.WireguardInstance{}
	if result := h.Handler.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return tpapiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := tpapiserver_lib.CreateResponse(tpapiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a wireguard instance.
// @Description Get a particular wireguard instance from the database.
// @ID get-v0-wireguardInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-instances/{id} [GET]
func (h Handler) GetWireguardInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardInstance
	wireguardInstanceID := c.Param("id")
	var wireguardInstance api_v0.WireguardInstance
	if result := h.Handler.DB.First(&wireguardInstance, wireguardInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return tpapiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := tpapiserver_lib.CreateResponse(nil, wireguardInstance, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing wireguard instance.
// @Description Update a wireguard instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating wireguard instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-wireguardInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param wireguardInstance body api_v0.WireguardInstance true "WireguardInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-instances/{id} [PATCH]
func (h Handler) UpdateWireguardInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardInstance
	wireguardInstanceID := c.Param("id")
	var existingWireguardInstance api_v0.WireguardInstance
	if result := h.Handler.DB.First(&existingWireguardInstance, wireguardInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return tpapiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := tpapiserver_lib.PayloadCheck(c, true, true, objectType, existingWireguardInstance); err != nil {
		return tpapiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedWireguardInstance api_v0.WireguardInstance
	if err := c.Bind(&updatedWireguardInstance); err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.Handler.DB.Model(&existingWireguardInstance).Updates(updatedWireguardInstance); result.Error != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingWireguardInstance.Reconciled {
		notifPayload, err := existingWireguardInstance.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.Handler.JS.Publish(notif.WireguardInstanceUpdateSubject, *notifPayload)
	}

	response, err := tpapiserver_lib.CreateResponse(nil, existingWireguardInstance, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing wireguard instance by replacing the entire object.
// @Description Replace a wireguard instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating wireguard instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-wireguardInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param wireguardInstance body api_v0.WireguardInstance true "WireguardInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-instances/{id} [PUT]
func (h Handler) ReplaceWireguardInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardInstance
	wireguardInstanceID := c.Param("id")
	var existingWireguardInstance api_v0.WireguardInstance
	if result := h.Handler.DB.First(&existingWireguardInstance, wireguardInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return tpapiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := tpapiserver_lib.PayloadCheck(c, true, true, objectType, existingWireguardInstance); err != nil {
		return tpapiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedWireguardInstance api_v0.WireguardInstance
	if err := c.Bind(&updatedWireguardInstance); err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := tpapiserver_lib.ValidateBoundData(c, updatedWireguardInstance, objectType); err != nil {
		return tpapiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedWireguardInstance.ID = existingWireguardInstance.ID
	if result := h.Handler.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedWireguardInstance); result.Error != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.Handler.DB.First(&existingWireguardInstance, wireguardInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return tpapiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := tpapiserver_lib.CreateResponse(nil, existingWireguardInstance, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a wireguard instance.
// @Description Delete a wireguard instance by ID from the database.
// @ID delete-v0-wireguardInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /randalljohnson-us/v0/wireguard-instances/{id} [DELETE]
func (h Handler) DeleteWireguardInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeWireguardInstance
	wireguardInstanceID := c.Param("id")
	var wireguardInstance api_v0.WireguardInstance
	if result := h.Handler.DB.First(&wireguardInstance, wireguardInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return tpapiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if wireguardInstance.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledWireguardInstance := api_v0.WireguardInstance{
			Reconciliation: tpapi_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.Handler.DB.Model(&wireguardInstance).Updates(scheduledWireguardInstance); result.Error != nil {
			return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := wireguardInstance.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.Handler.JS.Publish(notif.WireguardInstanceDeleteSubject, *notifPayload)
	} else {
		if wireguardInstance.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return tpapiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*wireguardInstance.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.Handler.DB.Delete(&wireguardInstance); result.Error != nil {
				return tpapiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := tpapiserver_lib.CreateResponse(nil, wireguardInstance, objectType)
	if err != nil {
		return tpapiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return tpapiserver_lib.ResponseStatus200(c, *response)
}
