// generated by 'threeport-sdk gen' but will not be regenerated - intended for modification

package wireguard

import (
	"context"
	"errors"
	"fmt"
	"strings"

	logr "github.com/go-logr/logr"
	"github.com/oracle/oci-go-sdk/v65/common"
	"github.com/oracle/oci-go-sdk/v65/containerengine"
	"github.com/oracle/oci-go-sdk/v65/core"
	v0 "github.com/randalljohnson/wireguard-threeport-module/pkg/api/v0"
	tpclient_v0 "github.com/randalljohnson/wireguard-threeport-module/pkg/client/v0"
	tpapi "github.com/threeport/threeport/pkg/api/v0"
	tpapi_v0 "github.com/threeport/threeport/pkg/api/v0"
	tpclient_lib "github.com/threeport/threeport/pkg/client/lib/v0"
	helmclient_v0 "github.com/threeport/threeport/pkg/client/v0"
	tpclient "github.com/threeport/threeport/pkg/client/v0"
	controller "github.com/threeport/threeport/pkg/controller/v0"
	kube "github.com/threeport/threeport/pkg/kube/v0"
	"gopkg.in/yaml.v3"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// v0WireguardInstanceCreated performs reconciliation when a v0 WireguardInstance
// has been created.
func v0WireguardInstanceCreated(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) (int64, error) {
	// Create HelmWorkloadInstance
	if err := createHelmWorkloadInstance(r, wireguardInstance, log); err != nil {
		return 0, fmt.Errorf("failed to create HelmWorkloadInstance: %w", err)
	}

	// Configure security list rules
	if err := configureSecurityListRules(r, wireguardInstance, log); err != nil {
		return 0, fmt.Errorf("failed to configure security list rules: %w", err)
	}

	return 0, nil
}

// v0WireguardInstanceUpdated performs reconciliation when a v0 WireguardInstance
// has been updated.
func v0WireguardInstanceUpdated(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) (int64, error) {
	// Get the associated HelmWorkloadInstance by name
	helmWorkloadInst, err := helmclient_v0.GetHelmWorkloadInstanceByName(r.APIClient, r.APIServer, *wireguardInstance.Name)
	if err != nil {
		return 0, fmt.Errorf("failed to get HelmWorkloadInstance: %w", err)
	}

	// Marshal the Helm values to YAML
	valuesYAML, err := yaml.Marshal(getHelmValues())
	if err != nil {
		return 0, fmt.Errorf("failed to marshal Helm values: %w", err)
	}
	valuesStr := string(valuesYAML)

	// Update the HelmWorkloadInstance values
	helmWorkloadInst.ValuesDocument = &valuesStr

	// Update the HelmWorkloadInstance using the client
	updatedInst, err := helmclient_v0.UpdateHelmWorkloadInstance(r.APIClient, r.APIServer, helmWorkloadInst)
	if err != nil {
		return 0, fmt.Errorf("failed to update HelmWorkloadInstance: %w", err)
	}

	// Optionally, you can log or use the updated instance
	log.Info("updated HelmWorkloadInstance", "name", updatedInst.Name)

	return 0, nil
}

// v0WireguardInstanceDeleted performs reconciliation when a v0 WireguardInstance
// has been deleted.
func v0WireguardInstanceDeleted(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) (int64, error) {
	// Remove security list rules first
	if err := removeSecurityListRules(r, wireguardInstance, log); err != nil {
		log.Error(err, "failed to remove security list rules, proceeding with HelmWorkloadInstance deletion")
		// Continue with deletion even if security list removal fails
	}

	// Delete HelmWorkloadInstance
	if err := cleanupHelmWorkloadInstance(r, wireguardInstance, log); err != nil {
		return 0, fmt.Errorf("failed to cleanup HelmWorkloadInstance: %w", err)
	}

	return 0, nil
}

// configureSecurityListRules configures the necessary security list rules for Wireguard
// to function properly in OCI environments.
func configureSecurityListRules(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) error {
	// Get the attached Kubernetes runtime instance ID
	kubernetesRuntimeInstanceId, err := tpclient.GetObjectIdByAttachedObject(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeKubernetesRuntimeInstance,
		v0.ObjectTypeWireguardInstance,
		*wireguardInstance.ID,
	)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes runtime instance by attachment: %w", err)
	}

	// Get the Kubernetes runtime instance
	kubernetesRuntimeInstance, err := tpclient.GetKubernetesRuntimeInstanceByID(
		r.APIClient,
		r.APIServer,
		*kubernetesRuntimeInstanceId,
	)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes runtime instance: %w", err)
	}

	// Get the Kubernetes runtime definition to determine the infrastructure provider
	kubernetesRuntimeDef, err := tpclient.GetKubernetesRuntimeDefinitionByID(
		r.APIClient,
		r.APIServer,
		*kubernetesRuntimeInstance.KubernetesRuntimeDefinitionID,
	)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes runtime definition: %w", err)
	}

	// Check if we're running on OCI
	// todo: use constant for "oci" string
	if *kubernetesRuntimeDef.InfraProvider != tpapi_v0.KubernetesRuntimeInfraProviderOKE {
		log.Info("not running on OCI, skipping security list configuration")
		return nil
	}

	// Get the default OCI account credentials
	ociAccount, err := tpclient.GetOciAccountByName(
		r.APIClient,
		r.APIServer,
		"default-account",
	)
	if err != nil {
		return fmt.Errorf("failed to get default OCI account: %w", err)
	}

	// Initialize OCI client using the account credentials
	ociClient := common.NewRawConfigurationProvider(
		*ociAccount.TenancyOCID,
		*ociAccount.UserOCID,
		*ociAccount.DefaultRegion,
		*ociAccount.KeyFingerprint,
		*ociAccount.PrivateKey,
		nil,
	)

	// Get the OCI OKE runtime instance to get the cluster OCID
	ociOkeRuntimeInstance, err := tpclient.GetOciOkeKubernetesRuntimeInstanceByName(
		r.APIClient,
		r.APIServer,
		*kubernetesRuntimeInstance.Name,
	)
	if err != nil {
		return fmt.Errorf("failed to get OCI OKE runtime instance: %w", err)
	}

	// Get the cluster OCID
	clusterOCID := *ociOkeRuntimeInstance.ClusterOCID

	// Create OCI clients for the required services
	vcnClient, err := core.NewVirtualNetworkClientWithConfigurationProvider(ociClient)
	if err != nil {
		return fmt.Errorf("failed to create VCN client: %w", err)
	}

	containerClient, err := containerengine.NewContainerEngineClientWithConfigurationProvider(ociClient)
	if err != nil {
		return fmt.Errorf("failed to create Container Engine client: %w", err)
	}

	// Get cluster details to find the VCN ID and subnets
	cluster, err := containerClient.GetCluster(context.Background(), containerengine.GetClusterRequest{
		ClusterId: &clusterOCID,
	})
	if err != nil {
		return fmt.Errorf("failed to get cluster details: %w", err)
	}

	// Get the load balancer subnet from cluster metadata
	lbSubnetID := cluster.Options.ServiceLbSubnetIds[0]
	lbSubnetResp, err := vcnClient.GetSubnet(context.Background(), core.GetSubnetRequest{
		SubnetId: &lbSubnetID,
	})
	if err != nil {
		return fmt.Errorf("failed to get load balancer subnet: %w", err)
	}
	lbSubnet := &lbSubnetResp.Subnet

	// Get node pools to find worker node subnets
	nodePools, err := containerClient.ListNodePools(context.Background(), containerengine.ListNodePoolsRequest{
		CompartmentId: ociAccount.TenancyOCID,
		ClusterId:     &clusterOCID,
	})
	if err != nil {
		return fmt.Errorf("failed to list node pools: %w", err)
	}

	// Get the first worker node subnet from node pools
	var workerSubnet *core.Subnet
	for _, nodePool := range nodePools.Items {
		if nodePool.SubnetIds != nil && len(nodePool.SubnetIds) > 0 {
			workerSubnetID := nodePool.SubnetIds[0]
			workerSubnetResp, err := vcnClient.GetSubnet(context.Background(), core.GetSubnetRequest{
				SubnetId: &workerSubnetID,
			})
			if err != nil {
				return fmt.Errorf("failed to get worker subnet: %w", err)
			}
			workerSubnet = &workerSubnetResp.Subnet
			break
		}
	}

	if workerSubnet == nil {
		return fmt.Errorf("failed to find worker subnet in node pools")
	}

	// Get the Wireguard service from Kubernetes to determine the exposed port
	kubeClient, _, err := kube.GetClient(
		kubernetesRuntimeInstance,
		false,
		r.APIClient,
		r.APIServer,
		r.EncryptionKey,
	)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes client: %w", err)
	}

	// Define the GVR for Service
	serviceGVR := schema.GroupVersionResource{
		Group:    "",
		Version:  "v1",
		Resource: "services",
	}

	// List services and filter for LoadBalancer type
	serviceList, err := kubeClient.Resource(serviceGVR).Namespace(*wireguardInstance.Name).List(
		context.Background(),
		metav1.ListOptions{
			FieldSelector: "spec.type=LoadBalancer",
		},
	)
	if err != nil {
		return fmt.Errorf("failed to list services: %w", err)
	} else if len(serviceList.Items) == 0 {
		return fmt.Errorf("failed to find wireguard service of type LoadBalancer")
	} else if len(serviceList.Items) > 1 {
		return fmt.Errorf("found multiple wireguard services of type LoadBalancer")
	}

	// Get the first service from the list
	serviceObj := serviceList.Items[0]

	// Extract the port from the unstructured object
	ports, found, err := unstructured.NestedSlice(serviceObj.Object, "spec", "ports")
	if err != nil || !found {
		return fmt.Errorf("failed to get ports from service: %w", err)
	}

	var wireguardPort int32
	for _, port := range ports {
		portMap, ok := port.(map[string]interface{})
		if !ok {
			continue
		}
		if name, ok := portMap["name"].(string); ok && name == "wg0" {
			if nodePort, ok := portMap["nodePort"].(int64); ok {
				wireguardPort = int32(nodePort)
				break
			}
			// Sometimes nodePort may be float64
			if nodePort, ok := portMap["nodePort"].(float64); ok {
				wireguardPort = int32(nodePort)
				break
			}
		}
	}
	if wireguardPort == 0 {
		return fmt.Errorf("failed to find Wireguard port in service")
	}

	// Get security lists for both subnets
	workerSecurityList, err := vcnClient.GetSecurityList(context.Background(), core.GetSecurityListRequest{
		SecurityListId: &workerSubnet.SecurityListIds[0],
	})
	if err != nil {
		return fmt.Errorf("failed to get worker subnet security list: %w", err)
	}

	lbSecurityList, err := vcnClient.GetSecurityList(context.Background(), core.GetSecurityListRequest{
		SecurityListId: &lbSubnet.SecurityListIds[0],
	})
	if err != nil {
		return fmt.Errorf("failed to get load balancer subnet security list: %w", err)
	}

	// check if the security list already has a rule for the wireguard port
	hasLoadBalancerRule := false
	for _, rule := range lbSecurityList.IngressSecurityRules {
		if rule.UdpOptions != nil && rule.UdpOptions.DestinationPortRange != nil {
			if *rule.UdpOptions.DestinationPortRange.Min == int(wireguardPort) &&
				*rule.UdpOptions.DestinationPortRange.Max == int(wireguardPort) &&
				strings.HasPrefix(*rule.Description, getModulePrefix(wireguardInstance)) {
				log.Info("security list already has a rule for the wireguard port", "port", wireguardPort)
				hasLoadBalancerRule = true
			}
		}
	}

	// Create load balancer subnet UDP ingress rule for Wireguard
	if !hasLoadBalancerRule {
		wireguardLoadBalancerRule := core.IngressSecurityRule{
			Protocol:    common.String("17"), // UDP
			Source:      common.String("0.0.0.0/0"),
			Description: common.String(fmt.Sprintf("%s: Allow Wireguard UDP traffic", getModulePrefix(wireguardInstance))),
			UdpOptions: &core.UdpOptions{
				DestinationPortRange: &core.PortRange{
					Min: common.Int(int(51820)),
					Max: common.Int(int(51820)),
				},
			},
		}

		// Update load balancer subnet security list
		lbRules := append(lbSecurityList.IngressSecurityRules, wireguardLoadBalancerRule)
		_, err = vcnClient.UpdateSecurityList(context.Background(), core.UpdateSecurityListRequest{
			SecurityListId: &lbSubnet.SecurityListIds[0],
			UpdateSecurityListDetails: core.UpdateSecurityListDetails{
				IngressSecurityRules: lbRules,
			},
		})
		if err != nil {
			return fmt.Errorf("failed to update load balancer subnet security list: %w", err)
		}
	}

	// Create worker subnet UDP ingress rule for Wireguard
	hasWorkerRule := false
	for _, rule := range workerSecurityList.IngressSecurityRules {
		if rule.UdpOptions != nil && rule.UdpOptions.DestinationPortRange != nil {
			if *rule.UdpOptions.DestinationPortRange.Min == int(wireguardPort) &&
				*rule.UdpOptions.DestinationPortRange.Max == int(wireguardPort) &&
				strings.HasPrefix(*rule.Description, getModulePrefix(wireguardInstance)) {
				log.Info("security list already has a rule for the wireguard port", "port", wireguardPort)
				hasWorkerRule = true
			}
		}
	}

	// Create worker subnet UDP ingress rule for Wireguard
	if !hasWorkerRule {
		wireguardWorkerRule := core.IngressSecurityRule{
			Protocol:    common.String("17"), // UDP
			Source:      common.String(*workerSubnet.CidrBlock),
			Description: common.String(fmt.Sprintf("%s: Allow Wireguard UDP traffic", getModulePrefix(wireguardInstance))),
			UdpOptions: &core.UdpOptions{
				DestinationPortRange: &core.PortRange{
					Min: common.Int(int(wireguardPort)),
					Max: common.Int(int(wireguardPort)),
				},
			},
		}

		// Update worker subnet security list
		workerRules := append(workerSecurityList.IngressSecurityRules, wireguardWorkerRule)
		_, err = vcnClient.UpdateSecurityList(context.Background(), core.UpdateSecurityListRequest{
			SecurityListId: &workerSubnet.SecurityListIds[0],
			UpdateSecurityListDetails: core.UpdateSecurityListDetails{
				IngressSecurityRules: workerRules,
			},
		})
		if err != nil {
			return fmt.Errorf("failed to update worker subnet security list: %w", err)
		}
	}

	log.Info("successfully configured security list rules for Wireguard",
		"instance", *wireguardInstance.Name,
		"port", wireguardPort,
		"workerSubnet", *workerSubnet.DisplayName,
		"lbSubnet", *lbSubnet.DisplayName,
	)

	return nil
}

// todo: how should this include the control plane instance name?
// getModulePrefix returns a prefixed string for the module
func getModulePrefix(
	// controlPlaneInstance *tpapi.ControlPlaneInstance,
	wireguardInstance *v0.WireguardInstance,
) string {
	return fmt.Sprintf(
		"%s/%s",
		"wireguard-threeport-module",
		*wireguardInstance.Name,
	)
}

// createHelmWorkloadInstance creates a new HelmWorkloadInstance for the Wireguard instance
func createHelmWorkloadInstance(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) error {
	// get attached Kubernetes runtime instance ID
	kubernetesRuntimeInstanceId, err := tpclient.GetObjectIdByAttachedObject(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeKubernetesRuntimeInstance,
		v0.ObjectTypeWireguardInstance,
		*wireguardInstance.ID,
	)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes runtime instance by attachment: %w", err)
	}

	// Get the associated WireguardDefinition
	wireguardDef, err := tpclient_v0.GetWireguardDefinitionByID(r.APIClient, r.APIServer, *wireguardInstance.WireguardDefinitionID)
	if err != nil {
		return fmt.Errorf("failed to get WireguardDefinition: %w", err)
	}

	// Get the associated HelmWorkloadDefinition
	helmWorkloadDef, err := helmclient_v0.GetHelmWorkloadDefinitionByName(r.APIClient, r.APIServer, *wireguardDef.Name)
	if err != nil {
		return fmt.Errorf("failed to get HelmWorkloadDefinition: %w", err)
	}

	// Create HelmWorkloadInstance for wg-portal
	helmWorkloadInst := &tpapi_v0.HelmWorkloadInstance{
		Instance: tpapi_v0.Instance{
			Name: wireguardInstance.Name,
		},
		HelmWorkloadDefinitionID:    helmWorkloadDef.ID,
		ValuesDocument:              helmWorkloadDef.ValuesDocument,
		KubernetesRuntimeInstanceID: kubernetesRuntimeInstanceId,
		ReleaseNamespace:            wireguardInstance.Name,
	}

	// Create the HelmWorkloadInstance using the client
	createdInst, err := helmclient_v0.CreateHelmWorkloadInstance(r.APIClient, r.APIServer, helmWorkloadInst)
	if err != nil && !errors.Is(err, tpclient_lib.ErrConflict) {
		return fmt.Errorf("failed to create HelmWorkloadInstance: %w", err)
	}

	log.Info("created HelmWorkloadInstance", "name", createdInst.Name)
	return nil
}

// cleanupHelmWorkloadInstance deletes the HelmWorkloadInstance associated with the Wireguard instance
func cleanupHelmWorkloadInstance(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) error {
	// Get the associated HelmWorkloadInstance by name
	helmWorkloadInst, err := helmclient_v0.GetHelmWorkloadInstanceByName(r.APIClient, r.APIServer, *wireguardInstance.Name)
	if err != nil {
		if errors.Is(err, tpclient_lib.ErrObjectNotFound) {
			// Instance already deleted, nothing to do
			return nil
		}
		return fmt.Errorf("failed to get HelmWorkloadInstance: %w", err)
	}

	// Delete the HelmWorkloadInstance using the client
	_, err = helmclient_v0.DeleteHelmWorkloadInstance(r.APIClient, r.APIServer, *helmWorkloadInst.ID)
	if err != nil {
		return fmt.Errorf("failed to delete HelmWorkloadInstance: %w", err)
	}

	log.Info("deleted HelmWorkloadInstance", "name", helmWorkloadInst.Name)
	return nil
}
