// generated by 'threeport-sdk gen' but will not be regenerated - intended for modification

package wireguard

import (
	"context"
	"errors"
	"fmt"
	"strings"

	logr "github.com/go-logr/logr"
	"github.com/oracle/oci-go-sdk/v65/common"
	"github.com/oracle/oci-go-sdk/v65/containerengine"
	"github.com/oracle/oci-go-sdk/v65/core"
	v0 "github.com/randalljohnson/wireguard-threeport-module/pkg/api/v0"
	tpclient_v0 "github.com/randalljohnson/wireguard-threeport-module/pkg/client/v0"
	tpapi "github.com/threeport/threeport/pkg/api/v0"
	tpapi_v0 "github.com/threeport/threeport/pkg/api/v0"
	tpclient_lib "github.com/threeport/threeport/pkg/client/lib/v0"
	helmclient_v0 "github.com/threeport/threeport/pkg/client/v0"
	tpclient "github.com/threeport/threeport/pkg/client/v0"
	controller "github.com/threeport/threeport/pkg/controller/v0"
	kube "github.com/threeport/threeport/pkg/kube/v0"
	"gopkg.in/yaml.v3"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// v0WireguardInstanceCreated performs reconciliation when a v0 WireguardInstance
// has been created.
func v0WireguardInstanceCreated(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) (int64, error) {
	// create HelmWorkloadInstance
	if err := createHelmWorkloadInstance(r, wireguardInstance, log); err != nil {
		return 0, fmt.Errorf("failed to create HelmWorkloadInstance: %w", err)
	}

	// configure security list rules
	if err := configureSecurityListRules(r, wireguardInstance, log); err != nil {
		return 0, fmt.Errorf("failed to configure security list rules: %w", err)
	}

	return 0, nil
}

// v0WireguardInstanceUpdated performs reconciliation when a v0 WireguardInstance
// has been updated.
func v0WireguardInstanceUpdated(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) (int64, error) {
	// get helm workload instance
	helmWorkloadInst, err := helmclient_v0.GetHelmWorkloadInstanceByName(r.APIClient, r.APIServer, *wireguardInstance.Name)
	if err != nil {
		return 0, fmt.Errorf("failed to get HelmWorkloadInstance: %w", err)
	}

	// marshal helm values
	valuesYAML, err := yaml.Marshal(getHelmValues())
	if err != nil {
		return 0, fmt.Errorf("failed to marshal Helm values: %w", err)
	}
	valuesStr := string(valuesYAML)

	// update values
	helmWorkloadInst.ValuesDocument = &valuesStr

	// update instance
	updatedInst, err := helmclient_v0.UpdateHelmWorkloadInstance(r.APIClient, r.APIServer, helmWorkloadInst)
	if err != nil {
		return 0, fmt.Errorf("failed to update HelmWorkloadInstance: %w", err)
	}

	// log update
	log.Info("updated HelmWorkloadInstance", "name", updatedInst.Name)

	return 0, nil
}

// v0WireguardInstanceDeleted performs reconciliation when a v0 WireguardInstance
// has been deleted.
func v0WireguardInstanceDeleted(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) (int64, error) {
	// Remove security list rules first
	if err := removeSecurityListRules(r, wireguardInstance, log); err != nil {
		log.Error(err, "failed to remove security list rules, proceeding with HelmWorkloadInstance deletion")
	}

	// delete HelmWorkloadInstance
	if err := cleanupHelmWorkloadInstance(r, wireguardInstance, log); err != nil {
		return 0, fmt.Errorf("failed to cleanup HelmWorkloadInstance: %w", err)
	}

	return 0, nil
}

// OciSetup holds all the necessary OCI clients and resources
type OciSetup struct {
	vcnClient          core.VirtualNetworkClient
	containerClient    containerengine.ContainerEngineClient
	lbSubnet           *core.Subnet
	workerSubnet       *core.Subnet
	wireguardPort      int32
	lbSecurityList     *core.SecurityList
	workerSecurityList *core.SecurityList
}

// setupOciResources initializes OCI clients and retrieves necessary resources
func setupOciResources(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) (*OciSetup, error) {
	// get runtime instance id
	kubernetesRuntimeInstanceId, err := tpclient.GetObjectIdByAttachedObject(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeKubernetesRuntimeInstance,
		v0.ObjectTypeWireguardInstance,
		*wireguardInstance.ID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get kubernetes runtime instance by attachment: %w", err)
	}

	// get runtime instance
	kubernetesRuntimeInstance, err := tpclient.GetKubernetesRuntimeInstanceByID(
		r.APIClient,
		r.APIServer,
		*kubernetesRuntimeInstanceId,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get kubernetes runtime instance: %w", err)
	}

	// get runtime definition
	kubernetesRuntimeDef, err := tpclient.GetKubernetesRuntimeDefinitionByID(
		r.APIClient,
		r.APIServer,
		*kubernetesRuntimeInstance.KubernetesRuntimeDefinitionID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get kubernetes runtime definition: %w", err)
	}

	// check oci provider
	if *kubernetesRuntimeDef.InfraProvider != tpapi_v0.KubernetesRuntimeInfraProviderOKE {
		return nil, fmt.Errorf("only oke is supported")
	}

	// get oci account
	ociAccount, err := tpclient.GetOciAccountByName(
		r.APIClient,
		r.APIServer,
		"default-account",
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get default oci account: %w", err)
	}

	// init oci client
	ociClient := common.NewRawConfigurationProvider(
		*ociAccount.TenancyOCID,
		*ociAccount.UserOCID,
		*ociAccount.DefaultRegion,
		*ociAccount.KeyFingerprint,
		*ociAccount.PrivateKey,
		nil,
	)

	// get oke instance
	ociOkeRuntimeInstance, err := tpclient.GetOciOkeKubernetesRuntimeInstanceByName(
		r.APIClient,
		r.APIServer,
		*kubernetesRuntimeInstance.Name,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get oci oke runtime instance: %w", err)
	}

	// get cluster id
	clusterOCID := *ociOkeRuntimeInstance.ClusterOCID

	// create oci clients
	vcnClient, err := core.NewVirtualNetworkClientWithConfigurationProvider(ociClient)
	if err != nil {
		return nil, fmt.Errorf("failed to create vcn client: %w", err)
	}

	containerClient, err := containerengine.NewContainerEngineClientWithConfigurationProvider(ociClient)
	if err != nil {
		return nil, fmt.Errorf("failed to create container engine client: %w", err)
	}

	// get cluster details
	cluster, err := containerClient.GetCluster(context.Background(), containerengine.GetClusterRequest{
		ClusterId: &clusterOCID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get cluster details: %w", err)
	}

	// get loadbalancer subnet
	lbSubnetID := cluster.Options.ServiceLbSubnetIds[0]
	lbSubnetResp, err := vcnClient.GetSubnet(context.Background(), core.GetSubnetRequest{
		SubnetId: &lbSubnetID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get loadbalancer subnet: %w", err)
	}
	lbSubnet := &lbSubnetResp.Subnet

	// get node pools
	nodePools, err := containerClient.ListNodePools(context.Background(), containerengine.ListNodePoolsRequest{
		CompartmentId: ociAccount.TenancyOCID,
		ClusterId:     &clusterOCID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list node pools: %w", err)
	}

	// get worker subnet
	var workerSubnet *core.Subnet
	for _, nodePool := range nodePools.Items {
		if nodePool.SubnetIds != nil && len(nodePool.SubnetIds) > 0 {
			workerSubnetID := nodePool.SubnetIds[0]
			workerSubnetResp, err := vcnClient.GetSubnet(context.Background(), core.GetSubnetRequest{
				SubnetId: &workerSubnetID,
			})
			if err != nil {
				return nil, fmt.Errorf("failed to get worker subnet: %w", err)
			}
			workerSubnet = &workerSubnetResp.Subnet
			break
		}
	}

	if workerSubnet == nil {
		return nil, fmt.Errorf("failed to find worker subnet in node pools")
	}

	// get wireguard service
	kubeClient, _, err := kube.GetClient(
		kubernetesRuntimeInstance,
		false,
		r.APIClient,
		r.APIServer,
		r.EncryptionKey,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get kubernetes client: %w", err)
	}

	// define service gvr
	serviceGVR := schema.GroupVersionResource{
		Group:    "",
		Version:  "v1",
		Resource: "services",
	}

	// list loadbalancer services
	serviceList, err := kubeClient.Resource(serviceGVR).Namespace(*wireguardInstance.Name).List(
		context.Background(),
		metav1.ListOptions{
			FieldSelector: "spec.type=loadbalancer",
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to list services: %w", err)
	} else if len(serviceList.Items) == 0 {
		return nil, fmt.Errorf("failed to find wireguard service of type loadbalancer")
	} else if len(serviceList.Items) > 1 {
		return nil, fmt.Errorf("found multiple wireguard services of type loadbalancer")
	}

	// get service
	serviceObj := serviceList.Items[0]

	// get port
	ports, found, err := unstructured.NestedSlice(serviceObj.Object, "spec", "ports")
	if err != nil || !found {
		return nil, fmt.Errorf("failed to get ports from service: %w", err)
	}

	var wireguardPort int32
	for _, port := range ports {
		portMap, ok := port.(map[string]interface{})
		if !ok {
			continue
		}
		if name, ok := portMap["name"].(string); ok && name == "wg0" {
			if nodePort, ok := portMap["nodePort"].(int64); ok {
				wireguardPort = int32(nodePort)
				break
			}
			// sometimes nodePort may be float64
			if nodePort, ok := portMap["nodePort"].(float64); ok {
				wireguardPort = int32(nodePort)
				break
			}
		}
	}
	if wireguardPort == 0 {
		return nil, fmt.Errorf("failed to find wireguard port in service")
	}

	// get security lists for both subnets
	if len(workerSubnet.SecurityListIds) == 0 {
		return nil, fmt.Errorf("worker subnet has no security lists")
	}
	if len(lbSubnet.SecurityListIds) == 0 {
		return nil, fmt.Errorf("loadbalancer subnet has no security lists")
	}

	workerSecurityList, err := vcnClient.GetSecurityList(context.Background(), core.GetSecurityListRequest{
		SecurityListId: &workerSubnet.SecurityListIds[0],
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get worker subnet security list: %w", err)
	}

	lbSecurityList, err := vcnClient.GetSecurityList(context.Background(), core.GetSecurityListRequest{
		SecurityListId: &lbSubnet.SecurityListIds[0],
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get loadbalancer subnet security list: %w", err)
	}

	return &OciSetup{
		vcnClient:          vcnClient,
		containerClient:    containerClient,
		lbSubnet:           lbSubnet,
		workerSubnet:       workerSubnet,
		wireguardPort:      wireguardPort,
		lbSecurityList:     &lbSecurityList.SecurityList,
		workerSecurityList: &workerSecurityList.SecurityList,
	}, nil
}

// configureSecurityListRules configures the necessary security list rules for Wireguard
func configureSecurityListRules(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) error {
	setup, err := setupOciResources(r, wireguardInstance, log)
	if err != nil {
		return err
	}

	// create security list manager
	manager := &SecurityListManager{
		vcnClient: &setup.vcnClient,
		log:       log,
	}

	// add loadbalancer rule
	lbRuleConfig := SecurityRuleConfig{
		Protocol:    "17", // udp
		Source:      "0.0.0.0/0",
		Description: fmt.Sprintf("%s: allow wireguard udp traffic", getModulePrefix(wireguardInstance)),
		Port:        setup.wireguardPort,
	}
	if err := manager.addSecurityRule(setup.lbSecurityList, lbRuleConfig); err != nil {
		return fmt.Errorf("failed to add loadbalancer security rule: %w", err)
	}

	// add worker rule
	workerRuleConfig := SecurityRuleConfig{
		Protocol:    "17", // udp
		Source:      *setup.workerSubnet.CidrBlock,
		Description: fmt.Sprintf("%s: allow wireguard udp traffic", getModulePrefix(wireguardInstance)),
		Port:        setup.wireguardPort,
	}
	if err := manager.addSecurityRule(setup.workerSecurityList, workerRuleConfig); err != nil {
		return fmt.Errorf("failed to add worker security rule: %w", err)
	}

	log.Info("successfully configured security list rules for wireguard",
		"instance", *wireguardInstance.Name,
		"port", setup.wireguardPort,
		"workerSubnet", *setup.workerSubnet.DisplayName,
		"lbSubnet", *setup.lbSubnet.DisplayName,
	)

	return nil
}

// removeSecurityListRules removes the security list rules for Wireguard
func removeSecurityListRules(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) error {
	setup, err := setupOciResources(r, wireguardInstance, log)
	if err != nil {
		return err
	}
	if setup == nil {
		return nil // not running on OCI
	}

	// create security list manager
	manager := &SecurityListManager{
		vcnClient: &setup.vcnClient,
		log:       log,
	}

	// remove loadbalancer rule
	if err := manager.removeSecurityRule(setup.lbSecurityList, getModulePrefix(wireguardInstance), setup.wireguardPort); err != nil {
		return fmt.Errorf("failed to remove loadbalancer security rule: %w", err)
	}

	// remove worker rule
	if err := manager.removeSecurityRule(setup.workerSecurityList, getModulePrefix(wireguardInstance), setup.wireguardPort); err != nil {
		return fmt.Errorf("failed to remove worker security rule: %w", err)
	}

	log.Info("successfully removed security list rules for wireguard",
		"instance", *wireguardInstance.Name,
		"workerSubnet", *setup.workerSubnet.DisplayName,
		"lbSubnet", *setup.lbSubnet.DisplayName,
	)

	return nil
}

// todo: how should this include the control plane instance name?
// getModulePrefix returns a prefixed string for the module
func getModulePrefix(
	// controlPlaneInstance *tpapi.ControlPlaneInstance,
	wireguardInstance *v0.WireguardInstance,
) string {
	return fmt.Sprintf(
		"%s/%s",
		"wireguard-threeport-module",
		*wireguardInstance.Name,
	)
}

// createHelmWorkloadInstance creates a new HelmWorkloadInstance for the Wireguard instance
func createHelmWorkloadInstance(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) error {
	// get runtime instance id
	kubernetesRuntimeInstanceId, err := tpclient.GetObjectIdByAttachedObject(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeKubernetesRuntimeInstance,
		v0.ObjectTypeWireguardInstance,
		*wireguardInstance.ID,
	)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes runtime instance by attachment: %w", err)
	}

	// Get the associated WireguardDefinition
	wireguardDef, err := tpclient_v0.GetWireguardDefinitionByID(r.APIClient, r.APIServer, *wireguardInstance.WireguardDefinitionID)
	if err != nil {
		return fmt.Errorf("failed to get WireguardDefinition: %w", err)
	}

	// Get the associated HelmWorkloadDefinition
	helmWorkloadDef, err := helmclient_v0.GetHelmWorkloadDefinitionByName(r.APIClient, r.APIServer, *wireguardDef.Name)
	if err != nil {
		return fmt.Errorf("failed to get HelmWorkloadDefinition: %w", err)
	}

	// Create HelmWorkloadInstance for wg-portal
	helmWorkloadInst := &tpapi_v0.HelmWorkloadInstance{
		Instance: tpapi_v0.Instance{
			Name: wireguardInstance.Name,
		},
		HelmWorkloadDefinitionID:    helmWorkloadDef.ID,
		ValuesDocument:              helmWorkloadDef.ValuesDocument,
		KubernetesRuntimeInstanceID: kubernetesRuntimeInstanceId,
		ReleaseNamespace:            wireguardInstance.Name,
	}

	// Create the HelmWorkloadInstance using the client
	createdInst, err := helmclient_v0.CreateHelmWorkloadInstance(r.APIClient, r.APIServer, helmWorkloadInst)
	if err != nil && !errors.Is(err, tpclient_lib.ErrConflict) {
		return fmt.Errorf("failed to create HelmWorkloadInstance: %w", err)
	}

	log.Info("created HelmWorkloadInstance", "name", createdInst.Name)
	return nil
}

// cleanupHelmWorkloadInstance deletes the HelmWorkloadInstance associated with the Wireguard instance
func cleanupHelmWorkloadInstance(
	r *controller.Reconciler,
	wireguardInstance *v0.WireguardInstance,
	log *logr.Logger,
) error {
	// Get the associated HelmWorkloadInstance by name
	helmWorkloadInst, err := helmclient_v0.GetHelmWorkloadInstanceByName(r.APIClient, r.APIServer, *wireguardInstance.Name)
	if err != nil {
		if errors.Is(err, tpclient_lib.ErrObjectNotFound) {
			// Instance already deleted, nothing to do
			return nil
		}
		return fmt.Errorf("failed to get HelmWorkloadInstance: %w", err)
	}

	// Delete the HelmWorkloadInstance using the client
	_, err = helmclient_v0.DeleteHelmWorkloadInstance(r.APIClient, r.APIServer, *helmWorkloadInst.ID)
	if err != nil {
		return fmt.Errorf("failed to delete HelmWorkloadInstance: %w", err)
	}

	log.Info("deleted HelmWorkloadInstance", "name", helmWorkloadInst.Name)
	return nil
}

// SecurityListManager manages security list rules
type SecurityListManager struct {
	vcnClient *core.VirtualNetworkClient
	log       *logr.Logger
}

// SecurityRuleConfig represents the configuration for a security rule
type SecurityRuleConfig struct {
	Protocol    string
	Source      string
	Description string
	Port        int32
}

// addSecurityRule adds a new security rule to a security list if it doesn't exist
func (m *SecurityListManager) addSecurityRule(securityList *core.SecurityList, config SecurityRuleConfig) error {
	if m.findExistingRule(securityList.IngressSecurityRules, config.Description, config.Port) {
		return nil
	}

	newRule := core.IngressSecurityRule{
		Protocol:    common.String(config.Protocol),
		Source:      common.String(config.Source),
		Description: common.String(config.Description),
		UdpOptions: &core.UdpOptions{
			DestinationPortRange: &core.PortRange{
				Min: common.Int(int(config.Port)),
				Max: common.Int(int(config.Port)),
			},
		},
	}

	rules := append(securityList.IngressSecurityRules, newRule)
	_, err := m.vcnClient.UpdateSecurityList(context.Background(), core.UpdateSecurityListRequest{
		SecurityListId: securityList.Id,
		UpdateSecurityListDetails: core.UpdateSecurityListDetails{
			IngressSecurityRules: rules,
		},
	})
	if err != nil {
		return fmt.Errorf("failed to update security list: %w", err)
	}

	return nil
}

// removeSecurityRule removes a security rule from a security list if it exists
func (m *SecurityListManager) removeSecurityRule(securityList *core.SecurityList, descriptionPrefix string, port int32) error {
	var updatedRules []core.IngressSecurityRule
	for _, rule := range securityList.IngressSecurityRules {
		// skip rules that match both our description prefix and port
		if rule.UdpOptions != nil &&
			rule.UdpOptions.DestinationPortRange != nil &&
			rule.Description != nil &&
			strings.HasPrefix(*rule.Description, descriptionPrefix) &&
			*rule.UdpOptions.DestinationPortRange.Min == int(port) &&
			*rule.UdpOptions.DestinationPortRange.Max == int(port) {
			continue
		}

		// keep all other rules
		updatedRules = append(updatedRules, rule)
	}

	if len(updatedRules) == len(securityList.IngressSecurityRules) {
		return nil // no rules were removed
	}

	_, err := m.vcnClient.UpdateSecurityList(context.Background(), core.UpdateSecurityListRequest{
		SecurityListId: securityList.Id,
		UpdateSecurityListDetails: core.UpdateSecurityListDetails{
			IngressSecurityRules: updatedRules,
		},
	})
	if err != nil {
		return fmt.Errorf("failed to update security list: %w", err)
	}

	return nil
}

// findExistingRule checks if a rule already exists in the security list
func (m *SecurityListManager) findExistingRule(rules []core.IngressSecurityRule, description string, port int32) bool {
	for _, rule := range rules {
		if rule.UdpOptions != nil && rule.UdpOptions.DestinationPortRange != nil {
			if *rule.UdpOptions.DestinationPortRange.Min == int(port) &&
				*rule.UdpOptions.DestinationPortRange.Max == int(port) &&
				*rule.Description == description {
				return true
			}
		}
	}
	return false
}
